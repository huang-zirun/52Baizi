---
description: Follow these rules when working on the frontend.
globs: 
---
### Frontend Rules

Follow these rules when working on the frontend.

It uses Next.js, Tailwind, Shadcn, and Framer Motion.

#### General Rules

- Use `lucide-react` for icons
- useSidebar must be used within a SidebarProvider

#### Components

- Use divs instead of other html tags unless otherwise specified
- Separate the main parts of a component's html with an extra blank line for visual spacing
- Always tag a component with either `use server` or `use client` at the top, including layouts and pages

##### Organization

- All components be named using kebab case like `example-component.tsx` unless otherwise specified
- Put components in `/_components` in the route if one-off components
- Put components in `/components` from the root if shared components

##### Data Fetching

- Fetch data in server components and pass the data down as props to client components.
- Use server actions from `/actions` to mutate data.

##### Data Flow Architecture

Follow this layered architecture pattern:
- **React Components** → **Server Actions** → **Services** (when complex logic is needed)
- Services handle domain-specific logic, external API integrations, and complex business rules
- Keep Server Actions lightweight and focused on data validation and orchestration

##### Server Components

- Use `"use server"` at the top of the file.
- Implement Suspense for asynchronous data fetching to show loading states while data is being fetched.
- If no asynchronous logic is required for a given server component, you do not need to wrap the component in `<Suspense>`. You can simply return the final UI directly since there is no async boundary needed.
- If asynchronous fetching is required, you can use a `<Suspense>` boundary and a fallback to indicate a loading state while data is loading.
- Server components cannot be imported into client components. If you want to use a server component in a client component, you must pass the as props using the "children" prop
- params in server pages should be awaited such as `const { courseId } = await params` where the type is `params: Promise<{ courseId: string }>`

Example of a server layout:

```tsx
"use server"

export default async function ExampleServerLayout({
  children
}: {
  children: React.ReactNode
}) {
  return children
}
```

Example of a server page (with async logic):

```tsx
"use server"

import { Suspense } from "react"
import { SomeAction } from "@/actions/some-actions"
import SomeComponent from "./_components/some-component"
import SomeSkeleton from "./_components/some-skeleton"

export default async function ExampleServerPage() {
  return (
    <Suspense fallback={<SomeSkeleton className="some-class" />}>
      <SomeComponentFetcher />
    </Suspense>
  )
}

async function SomeComponentFetcher() {
  const { data } = await SomeAction()
  return <SomeComponent className="some-class" initialData={data || []} />
}
```

Example of a server page (no async logic required):

```tsx
"use server"

import SomeClientComponent from "./_components/some-client-component"

// In this case, no asynchronous work is being done, so no Suspense or fallback is required.
export default async function ExampleServerPage() {
  return <SomeClientComponent initialData={[]} />
}
```

Example of a server component:

```tsx
"use server"

interface ExampleServerComponentProps {
  // Your props here
}

export async function ExampleServerComponent({
  props
}: ExampleServerComponentProps) {
  // Your code here
}
```

##### Client Components

- Use `"use client"` at the top of the file
- Client components can safely rely on props passed down from server components, or handle UI interactions without needing <Suspense> if there’s no async logic.
- Never use server actions in client components. If you need to create a new server action, create it in `/actions`

Example of a client page:

```tsx
"use client"

export default function ExampleClientPage() {
  // Your code here
}
```

Example of a client component:

```tsx
"use client"

interface ExampleClientComponentProps {
  initialData: any[]
}

export default function ExampleClientComponent({
  initialData
}: ExampleClientComponentProps) {
  // Client-side logic here
  return <div>{initialData.length} items</div>
}
```


Next.js Server/Client Constraints (Must Follow)

If a file contains the "use server" directive:

Only async function exports are allowed (Server Actions).

It is forbidden to export objects, arrays, literals, constants, enums, values other than types, React components, or non-async functions.

If you need to share constants, schemas, or types: move them to a separate module without the "use server" directive, and import them from there.

Files like app/layout.tsx, app/page.tsx, etc. must not include "use server".
These files are RSC (React Server Components) or layout components. If you need Server Actions:

Declare them in app/actions.ts (or any separate *.server.ts) with export async function ... (and "use server" at the top of that file).

Import and use them in the component via import { action } from './actions'.

If you need client-side interactivity:
Use the "use client" directive at the top of the file, and do not include any client logic or component exports in a "use server" file.

All return values must be JSON-serializable.
When necessary, trim or convert complex objects into plain POJOs.

Output Structure Requirements

Automatically split code into multiple files as needed (e.g., app/layout.tsx, app/actions.ts, lib/constants.ts).

Clearly specify at the top of each file whether it includes "use server" or "use client", and explain the reason.

If any requirements conflict with these constraints, always prioritize these constraints and explain the trade-off in comments.